<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grade</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <style>
        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: #141414;
            color: #ffffff;
            margin: 0;
            padding: 0;
        }

        h1,
        h2 {
            margin: 1rem;
            font-size: 24px;
        }

        select,
        button {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: #e50914;
            color: #ffffff;
            border: none;
            font-size: 1rem;
            padding: 0.5rem;
            cursor: pointer;
            margin: 1rem;
            height: 2.5rem;
            height: 2.5rem;
            height: 2.5rem;
        }

        button:hover {
            background-color: #b20710;
            border: 1px solid #fff;
        }

        select {
            background-color: #000;
            border: 1px solid #fff;
        }

        ul {
            list-style-type: none;
            padding-left: 1rem;
        }

        ul li {
            margin: 0.3rem;
        }

        .navbar {
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 1rem;
            font-size: 1rem;
        }

        .navbar a {
            color: #ffffff;
            text-decoration: none;
            margin-right: 1rem;
        }

        .navbar a:hover {
            color: #e50914;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .box {
            background-color: rgba(0, 0, 0, 0.1);
            border: 1px solid #d4d4d4;
            border-radius: 5px;
            padding: 0;
            margin: 5px;
            width: 200px;
            height: 160px;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.2s ease-in-out;
        }

        .box:hover {
            transform: scale(1.1);
        }

        .box span {
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            line-height: 24px;
            padding: 10px;
        }
    </style>

    <script>
        // Cole aqui o código da classe Graph e as funções findRelatedVertices e findDependenciesInGraph
        class Graph {

            constructor(edges, directed = false) {
                this.directed = directed;
                this.neighbors = {};
                this.addEdges(edges);
            }

            addEdges(edges) {
                for (const [x, y] of edges) {
                    if (!this.neighbors[x]) {
                        this.neighbors[x] = [];
                    }
                    this.neighbors[x].push(y);
                    if (!this.directed) {
                        if (!this.neighbors[y]) {
                            this.neighbors[y] = [];
                        }
                        this.neighbors[y].push(x);
                    } else {
                        if (!this.neighbors[y]) {
                            this.neighbors[y] = [];
                        }
                    }
                }
            }

            getEdges() {
                const edges = [];
                for (const key in this.neighbors) {
                    for (const value of this.neighbors[key]) {
                        edges.push([key, value]);
                    }
                }
                return edges;
            }

            getVertices() {
                return Object.keys(this.neighbors);
            }

            edgeExists(edge) {
                const [x, y] = edge;
                return x in this.neighbors && this.neighbors[x].includes(y);
            }
        }

        function findRelatedVertices(graph, vertex) {
            const visited = {};
            for (const key of graph.getVertices()) {
                visited[key] = false;
            }
            const initialVertex = vertex;
            const relations = [];
            const directDependents = [];
            const indirectDependents = [];

            function recDfs(graph, vertex) {
                visited[vertex] = true;

                for (const neighbor of graph.neighbors[vertex]) {
                    if (!visited[neighbor]) {
                        if (vertex === initialVertex) {
                            directDependents.push(neighbor);
                        } else {
                            indirectDependents.push(neighbor);
                        }
                        relations.push([vertex, neighbor]);
                        recDfs(graph, neighbor);
                    }
                }
            }

            recDfs(graph, vertex);

            return [directDependents, indirectDependents, relations];
        }

        function findDependenciesInGraph(graph, vertex) {
            const visited = {};
            for (const key of graph.getVertices()) {
                visited[key] = false;
            }
            const targetVertex = vertex;
            const dependencies = [];
            const dependenciesPaths = [];

            function recDfs(graph, vertex) {
                visited[vertex] = true;
                dependencies.push(vertex);

                if (vertex === targetVertex) {
                    dependenciesPaths.push([...dependencies]);
                } else {
                    for (const neighbor of graph.neighbors[vertex]) {
                        if (!visited[neighbor]) {
                            recDfs(graph, neighbor);
                        }
                    }
                }

                dependencies.pop();
                visited[vertex] = false;
            }

            for (const vertex of graph.getVertices()) {
                if (!visited[vertex]) {
                    recDfs(graph, vertex);
                }
            }

            const result = [];
            for (const paths of dependenciesPaths) {
                const temp = new Set([...paths].filter(x => !result.includes(x)));
                result.push(...temp);
            }

            const index = result.indexOf(targetVertex);
            if (index !== -1) {
                result.splice(index, 1);
            }
            result.sort();

            return result;
        }
    </script>
    <script>
        const data = [
            {
                "materia": "Algoritmos e Programação de Computadores",
                "tranca": ["Desenvolvimento de Software", "Estruturas de Dados 1", "Orientação a Objetos"]
            },
            {
                "materia": "Desenho Industrial Assistido por Computador",
                "tranca": ["Interação Humano Computador"]
            },
            {
                "materia": "Engenharia e Ambiente",
                "tranca": []
            },
            {
                "materia": "Introdução à Engenharia",
                "tranca": []
            },
            {
                "materia": "Cálculo 1",
                "tranca": ["Probabilidade e Estatística Aplicada à Engenharia", "Projeto e Análise de Algoritmos", "Cálculo 2"]
            },
            {
                "materia": "Cálculo 2",
                "tranca": ["Métodos Numéricos para Engenharia"]
            },
            {
                "materia": "Física 1",
                "tranca": []
            },
            {
                "materia": "Física 1 Experimental",
                "tranca": []
            },
            {
                "materia": "Introdução à Álgebra Linear",
                "tranca": ["Teoria de Eletrônica Digital 1", "Prática de Eletrônica Digital 1"]
            },
            {
                "materia": "Probabilidade e Estatística Aplicada à Engenharia",
                "tranca": []
            },
            {
                "materia": "Desenvolvimento de Software",
                "tranca": []
            },
            {
                "materia": "Métodos Numéricos para Engenharia",
                "tranca": []
            },
            {
                "materia": "Engenharia Econômica",
                "tranca": ["Gestão da Produção e Qualidade"]
            },
            {
                "materia": "Humanidades e Cidadania",
                "tranca": []
            },
            {
                "materia": "Teoria de Eletrônica Digital 1",
                "tranca": ["Fundamentos de Arquiteturas de Computadores"]
            },
            {
                "materia": "Prática de Eletrônica Digital 1",
                "tranca": ["Fundamentos de Arquiteturas de Computadores"]
            },
            {
                "materia": "Orientação a Objetos",
                "tranca": ["Projeto Integrador de Engenharia 1", "Métodos de Desenvolvimento de Software", "Paradigmas de Programação"]
            },
            {
                "materia": "Matemática Discreta 1",
                "tranca": ["Matemática Discreta 2"]
            },
            {
                "materia": "Projeto Integrador de Engenharia 1",
                "tranca": ["Projeto Integrador de Engenharia 2"]
            },
            {
                "materia": "Matemática Discreta 2",
                "tranca": ["Sistemas de Banco de Dados 1"]
            },
            {
                "materia": "Fundamentos de Arquiteturas de Computadores",
                "tranca": ["Fundamentos de Sistemas Operacionais"]
            },
            {
                "materia": "Estruturas de Dados 1",
                "tranca": ["Estruturas de Dados 2", "Projeto e Análise de Algoritmos", "Compiladores 1"]
            },
            {
                "materia": "Métodos de Desenvolvimento de Software",
                "tranca": ["Requisitos de Software", "Testes de Software"]
            },
            {
                "materia": "Gestão da Produção e Qualidade",
                "tranca": ["Qualidade de Software 1"]
            },
            {
                "materia": "Interação Humano Computador",
                "tranca": ["Qualidade de Software 1"]
            },
            {
                "materia": "Requisitos de Software",
                "tranca": ["Arquitetura e Desenho de Software"]
            },
            {
                "materia": "Sistemas de Banco de Dados 1",
                "tranca": ["Sistemas de Banco de Dados 2"]
            },
            {
                "materia": "Fundamentos de Sistemas Operacionais",
                "tranca": ["Fundamentos de Redes de Computadores", "Fundamentos de Sistemas Embarcados"]
            },
            {
                "materia": "Compiladores 1",
                "tranca": ["Paradigmas de Programação"]
            },
            {
                "materia": "Estruturas de Dados 2",
                "tranca": ["Programação para Sistemas Paralelos e Distribuídos"]
            },
            {
                "materia": "Projeto e Análise de Algoritmos",
                "tranca": []
            },
            {
                "materia": "Sistemas de Banco de Dados 2",
                "tranca": []
            },
            {
                "materia": "Fundamentos de Redes de Computadores",
                "tranca": ["Programação para Sistemas Paralelos e Distribuídos"]
            },
            {
                "materia": "Arquitetura e Desenho de Software",
                "tranca": ["Paradigmas de Programação", "Técnicas de Programação em Plataformas Emergentes"]
            },
            {
                "materia": "Testes de Software",
                "tranca": ["Gerência de Configuração e Evolução de Software", "Técnicas de Programação em Plataformas Emergentes"]
            },
            {
                "materia": "Qualidade de Software 1",
                "tranca": []
            },
            {
                "materia": "Técnicas de Programação em Plataformas Emergentes",
                "tranca": ["Engenharia de Produto de Software"]
            },
            {
                "materia": "Paradigmas de Programação",
                "tranca": []
            },
            {
                "materia": "Fundamentos de Sistemas Embarcados",
                "tranca": []
            },
            {
                "materia": "Programação para Sistemas Paralelos e Distribuídos",
                "tranca": []
            },
            {
                "materia": "Engenharia de Produto de Software",
                "tranca": ["Projeto Integrador de Engenharia 2"]
            },
            {
                "materia": "Gerência de Configuração e Evolução de Software",
                "tranca": []
            },
            {
                "materia": "Estágio Supervisionado",
                "tranca": []
            },
            {
                "materia": "Trabalho de Conclusão de Curso 1",
                "tranca": ["Trabalho de Conclusão de Curso 2"]
            },
            {
                "materia": "Projeto Integradorde Engenharia 2",
                "tranca": []
            },
            {
                "materia": "Trabalho de Conclusão de Curso 2",
                "tranca": []
            }
        ];

        const edges = [];

        for (const subject of data) {
            if (subject.tranca.length === 0) {
                edges.push([subject.materia, ""]);
            } else {
                for (const dependency of subject.tranca) {
                    edges.push([subject.materia, dependency]);
                }
            }
        }


        const graph = new Graph(edges);
    </script>
</head>

<body>
   
    <h1>Selecione uma matéria</h1>
    <select id="vertex-select"></select>
    <button onclick="submitForm()">Enviar <b> > </b> </button>

    
    <div id="dependencies-carousel" class="carousel slide" data-ride="carousel">
        <ol class="carousel-indicators">
            <li data-target="#dependencies-carousel" data-slide-to="0" class="active"></li>
            <li data-target="#dependencies-carousel" data-slide-to="1"></li>
            <li data-target="#dependencies-carousel" data-slide-to="2"></li>
        </ol>
        <div class="carousel-inner">
            <div class="carousel-item active">
                <h3>Dependentes Diretos</h3>
                <div id="direct-dependents" class="container"></div>
            </div>
            <div class="carousel-item">
                <h3>Dependentes Indiretos</h3>
                <div id="indirect-dependents" class="container"></div>
            </div>
            <div class="carousel-item">
                <h3>Dependências</h3>
                <div id="dependencies" class="container"></div>
            </div>
        </div>
        <a class="carousel-control-prev" href="#dependencies-carousel" role="button" data-slide="prev">
            <span class="carousel-control-prev-icon" aria-hidden="true"></span>
            <span class="sr-only">Anterior</span>
        </a>
        <a class="carousel-control-next" href="#dependencies-carousel" role="button" data-slide="next">
            <span class="carousel-control-next-icon" aria-hidden="true"></span>
            <span class="sr-only">Próximo</span>
        </a>
    </div>

    <script>
        const vertexSelect = document.getElementById('vertex-select');
        const directDependents = document.getElementById('direct-dependents');
        const indirectDependents = document.getElementById('indirect-dependents');
        const dependenciesList = document.getElementById('dependencies');

        function populateCarousel(directDependencies, indirectDependencies, dependencies) {
            // Dependentes diretos
            const directDependenciesContainer = document.getElementById('direct-dependents');
            directDependenciesContainer.innerHTML = '';
            directDependencies.forEach((subject) => {
                const box = document.createElement('div');
                box.className = 'box';
                const text = document.createElement('span');
                text.textContent = subject;
                box.appendChild(text);
                directDependenciesContainer.appendChild(box);
            });

            // Dependências
            const dependenciesContainer = document.getElementById('dependencies');
            dependenciesContainer.innerHTML = '';
            dependencies.forEach((dependency) => {
                const box = document.createElement('div');
                box.className = 'box';
                const text = document.createElement('span');
                text.textContent = dependency;
                box.appendChild(text);
                dependenciesContainer.appendChild(box);
            });


            // Ativa o primeiro item do carousel
            const carousel = document.querySelector('#dependencies-carousel');
            const carouselItems = carousel.querySelectorAll('.carousel-item');
            carouselItems[0].classList.add('active');
        }
        function populateSelect() {
            const vertices = graph.getVertices();
            const index = vertices.indexOf('');
            if (index !== -1) {
                vertices.splice(index, 1);
            }
            vertices.forEach((vertex) => {
                const option = document.createElement('option');
                option.value = vertex;
                option.textContent = vertex;
                vertexSelect.appendChild(option);
            });
        }

        function submitForm() {
            const vertex = vertexSelect.value;

            // Dependentes diretos e indiretos
            const dependents = findRelatedVertices(graph, vertex);
            const directDependencies = dependents[0];
            const indirectDependencies = dependents[1];

            // Dependências
            const dependencies = findDependenciesInGraph(graph, vertex);

            populateCarousel(directDependencies, indirectDependencies, dependencies);
        }

        populateSelect();
        // Dependentes indiretos
        const indirectDependenciesContainer = document.getElementById('indirect-dependents');
        indirectDependenciesContainer.innerHTML = '';
        indirectDependencies.forEach((subject) => {
            const box = document.createElement('div');
            box.className = 'box';
            const text = document.createElement('span');
            text.textContent = subject;
            box.appendChild(text);
            indirectDependenciesContainer.appendChild(box);
        });

    </script>

</body>

</html>